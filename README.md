# mytaskbar

## 何を目的としたプログラムか
　Win10までタスクバーにあった２つの機能は、Win11では使えなくなってしまいました。

* 「ツールバー」
* 「ラベル表示されたウィンドウリストからウィンドウを切り替え」

後者は23H2でラベル表示は復活しましたが、タスクバー表示位置を左右に振ることが依然できないため、ウィンドウの数が多いと「ラベルを一望してのウィンドウ切替」ということができない状況です。

Win11において、Win10タスクバーを復活する手順はありますが、安心して長らく使っていくには不安があります。これらをWin11で代替する目的で、Win10タスクバーにあった「ツールバー」や「ラベル付きウィンドウの縦並びリスト」をホットキーで画面の任意位置、任意タイミングで表示して利用できるプログラムです。

## 機能
1. アプリランチャー（アイコン表示、ファイル一覧表示）
2. ウィンドウ切替（ウィンドウ一覧表示）

## 画面
1. アプリランチャー（アイコン表示、ファイル一覧表示）
2. 子フォルダ表示プロパティ（フォルダ単位）
3. ウィンドウ切替（ウィンドウ一覧表示）
4. ホットキー設定
5. ウィンドウリスト:ソート設定

## インストールとアンインストール
* 「mytaskbar.exe」を任意のフォルダに配置します。exe単体で動作し、付属するファイルはありません。
* 迷う人はとりあえず、デスクトップに置いて起動しても大丈夫です。
* このプログラムは設定をレジストリに保存しますが、後からexeの配置を変えても設定に影響しません。


* アンインストールは、exeファイルとレジストリ「HKEY_CURRENT_USER\SOFTWARE\myprogram」を削除します。
* レジストリの意味が分からない人は放っておいても問題にはなりません。

## プログラムの起動と終了
* exeを起動するとウィンドウの表示無く常駐し、タスクバー通知アイコンやホットキーを通して操作します。
* タスクバー通知アイコンは、マウスカーソルをあてて「mytaskbar」と表示されるアイコンが対象です。
* プログラムの終了方法は、タスクバー通知アイコン「mytaskbar」を右クリックし「終了」を選択します。

## mytaskbar.exeの起動引数オプション
　exeの引数は、後述の二重起動時のホットキー動作(半角2文字)のみで、それ以外のオプションはありません。

## タスクバー通知アイコンの変更方法
* レジストリ「HKEY_CURRENT_USER\SOFTWARE\myprogram\mytaskbar」キーの「notify_icon」に文字列を登録
* 文字列にはアイコンの含んだファイルのフルパスを指定。
* フルパスのあとに「|」と番号を追記すると、ファイル内のアイコンインデックスを指定可能

**応用例**：アイコンのインデックス特定

C:\Windows\System32\shell32.dll や、imageres.dllにアイコンが多く含まれるため、好きなアイコンの利用が可能です。
ただし、数が多すぎてインデックスを数えるのは大変なため、特定方法を説明します。
適当なフォルダを右クリックして「プロパティ」を開き、「カスタマイズ」タブから「アイコンの変更」ボタンを押すことで、
アイコンを選択して変更します。フォルダ内にdesktop.iniができるので、メモ帳などで開くとIconResourceの記述で、
インデックス番号を読み取れます。desktop.iniの表示にはフォルダオプションで隠しファイルの表示設定が必要です。

## アプリランチャーの使い方（はじめの一歩）

基本的な考え方は、Win10までにあったタスクバーのツールバー（昔はクイック起動と呼ばれていた機能）と全く同じです。
一般的なランチャーのように、どんなアプリを起動するかをランチャー用に設定するような使い方ではありません。

**大まかな流れ**

1. 任意の専用フォルダを作って、そこによく使うアプリやファイルのショートカットを集めます。
2. ホットキー設定画面で登録します。
3. 設定したホットキーで①のフォルダをランチャー表示します。

**詳細な手順**

1. **A) フォルダ作成**

任意の場所にフォルダを作成します。デスクトップ上でも構いません。後で好きな位置に変えることもできます。
ここでは、デスクトップ上に「taskbar」というフォルダを作成したと仮定します。

1. **B) ショートカット配置**

「taskbar」フォルダ内にランチャー表示したいアプリのショートカットを配置します。
「taskbar」をデスクトップ上でダブルクリックしてエクスプローラを表示しておきます。
スタートメニューにあるアプリなら、そのアプリを「taskbar」フォルダへドラッグしてショートカットを配置できます。
スタートメニューになくても任意のexeやbatファイル等を、エクスプローラ上で右クリックしてショートカットを作成し
「taskbar」フォルダへ配置することができます。
アプリである必要もなく、よく使うフォルダへのショートカットや、よく使うwordやexeclファイル等へのショートカットでも構いません。
ショートカットである必要もないのでexeやbatファイルの実体やwordファイルの実体等、どんなファイルを置いても構いません。

2. **ホットキー設定画面**

上で作った「taskbar」フォルダをアイコンランチャーとして表示してみましょう。
「mytaskbar.exe」を起動すると、タスクバー右側の通知アイコン欄に「mytaskbar」のアイコンが追加されます。
アイコンを右クリックしてポップアップメニューから「ホットキー設定」を選んでください。
設定ダイアログが表示されたら、「追加」ボタンをクリックしてホットキーを一つ追加します。

以下のように入力してください。
* ランチャーを選択(デフォルトのまま)。
* SHIFT, ALT, NONEを選択欄から選び、好きなキー(a-z,1-0,記号)を１文字入力。

NONEはここでは選ばない(使い方は後述)。CTRL+SHIFT(ALT)+入力した文字がホットキーとなる。
例として、SHIFT,Aを入力したとします。

* ターゲット：上で作成した「taskbar」フォルダのフルパスを入力

　　　C:\Users\～あなたのユーザ名～\Desktop\taskbar

* 表示：アイコンを選択
* アイコンサイズ：大(デフォルトのまま)
* ウィンドウサイズ：W「0」×H「0」(デフォルトのまま)
* システムファイル：「表示」チェックを外す(デフォルトのまま)

* 右下「設定」ボタンを押して、ダイアログを閉じます。


3. ホットキーを押す

ダイアログを閉じたら、入力したホットキーを押します。例ではCTRL+SHIFT+Aキーを押します。
「taskbar」フォルダに配置したショートカットのアイコンが並んで表示されます。
好きなアイコンをクリックし起動することを確かめてください。
アイテムをミドルボタンでドラッグするとソート順を変えることができます。

　

ここまでが、アプリランチャーの基本的な使い方です。設定項目の詳細や応用例は後述します。

## ウィンドウ切替の使い方（はじめの一歩）

**大まかな流れ**

1. ホットキー設定画面で登録します。
2. 設定したホットキーでウィンドウ一覧を表示します。

**詳細な手順**

1. **ホットキー設定画面**

「mytaskbar.exe」を起動すると、タスクバー右側の通知アイコン欄に「mytaskbar」のアイコンが追加されます。
アプリランチャーの手順を実行済みで、すでに「mytaskbar.exe」を起動している場合は二重起動は不要です。
通知アイコンを右クリックしてポップアップメニューから「ホットキー設定」を選んでください。

設定ダイアログが表示されたら、「追加」ボタンをクリックしてホットキーを一つ追加します。

以下のように入力してください。
* 「ランチャー」欄を「ウィンドウリスト」に選択変更。
* SHIFT, ALT, NONEを選択欄から選び、好きなキー(a-z,1-0,記号)を１文字入力。

NONEはここでは選ばない(使い方は後述)。CTRL+SHIFT(ALT)+入力した文字がホットキーとなる。
例として、SHIFT,Zを入力したとします。

* ウィンドウサイズ：W「0」×H「0」(デフォルトのまま)
* その他の項目は無効化され変更不可
* 右下「設定」ボタンを押して、ダイアログを閉じます。

2. **ホットキーを押す**

ダイアログを閉じたら、入力したホットキーを押します。
例ではCTRL+SHIFT+Zキーを押します。
いま開いているウィンドウのアイコンとラベルの一覧が縦で表示され、左クリックでウィンドウを切り替えることができます。
右クリックでシステムメニューを開くことができます(閉じる、最大化、最小化など)。
一覧は同じアプリでグループ化され、左ドラッグにてグループ単位のソート順を入れ替えることができます。

　

ここまでが、ウィンドウ切替の基本的な使い方です。アイテムのソートに関しての設定方法は後述します。

## mytaskbar.exeの二重起動

　・初回にexe起動すると常駐し、２回目以降は新たなプログラムは起動せず、既に常駐しているプログラムに作用します。
　　以下のホットキー設定をしないまま、２回目起動すると、エラーダイアログが表示されます。

　・ホットキー設定画面にて、キー指定を「NONE」＋「!」とすると、２回目起動時の動作を指定することができます。

　応用例：タスクバーのボタンでウィンドウ切替の一覧を表示

　　・エクスプローラ上でmytaskbar.exeを右クリックして、「タスクバーにピン留めする」を選ぶ。
　　・ホットキー設定画面で「ウィンドウリスト」、「NONE」＋「!」を設定。
　　・使い方のイメージ）
　　　ＰＣを起動したらまずタスクバーのピン留めボタンで本プログラムの１回目を起動。
　　　２回目以降、クリックするとウィンドウ切替一覧が表示される。
　　・ホットキーではなく、タスクバーに備わった機能であるかのような操作感でウィンドウ切替を利用可能。

　応用例：タスクバーのピン留めアイコンを変えたい

　　このプログラムの使い方ではありませんが・・・。
　　・mytaskbar.exeを右クリックして仮初めのショートカットを作成する。
　　・ショートカットを右クリックしてプロパティを開き、「アイコンの変更」ボタンをクリックして、アイコンを設定。
　　・プロパティを閉じ、ショートカットを右クリックして「タスクバーにピン留めする」を選ぶ。
　　・仮初めのショートカットファイルは消しても問題なし。

　・exe起動時に引数を与えると、ホットキーの動作を押したのと同じ動作をさせることができます。
　　引数には例の通り、2文字指定します。半角指定で、アルファベットは大文字しか反応しません。

　　　CTRL+SHIFT+Aの設定を動作させたい場合　→　mytaskbar.exe SA
　　　CTRL+ALT+Dの設定を起動させたい場合　→　mytaskbar.exe AD

　・ホットキー設定画面における「NONE」の意味は、ホットキーを登録せずにexe二重起動だけ使いたい時に設定します。
　　特に「!」は特殊な意味として、引数無しの時の挙動を指定します。
　　「NONE」にもキーとして「1～0、A～Z、-^|@[;:],./_」の48種(!を入れると49種)が指定可能です。
　　ホットキーのように実際に押すわけではないので、キーに何を指定するかは引数を区別する意味しかありません。
　　「mytaskbar.exe」(引数なし)、「mytaskbar.exe N!」は同じ意味で、どちらも同じ動作をします。

　　　NONE+Aの設定を動作させたい場合　→　mytaskbar.exe NA

　応用例：タスクバーのボタンでアプリランチャーを表示

　　上記の引数なしの二重起動によるウィンドウ切替の一覧のピン留めを生かしつつ、もうひとつ、
　　アプリランチャーのピン留めを追加します。

　　・ホットキー設定画面でアプリランチャーを設定します。ホットキーを使うならお好みのキーを指定します。
　　　ホットキーを使わない場合は、「NONE」＋「1」などを設定します。ここでは「SHIFT」＋「A」
　　・mytaskbar.exeを右クリックして仮初めのショートカットを作成する。
　　・ショートカットを右クリックしてプロパティを開き、リンク先の末尾に空白＋「SA」を追加（SAの部分は例の場合）。
　　・プロパティを閉じ、ショートカットを右クリックして「タスクバーにピン留めする」を選ぶ。
　　・仮初めのショートカットファイルは消しても問題なし。
　　・これで、アプリランチャーもタスクバーに備わった機能であるかのような操作感で利用可能。

　応用例：バッチファイルがタスクバーのピン留めできないんだけど

　　もはやこのプログラムとは何の関係もありませんが・・・一応。
　　・cmd.exeへのショートカットを作成し、引数として、「/c "バッチファイルのフルパス"」とすればピン留め可能。

## ホットキー設定画面の詳細

　ここまででホットキー設定画面のうち、キー指定欄の説明をしました。残りの部分を説明します。

　・右下の「設定」ボタンは設定を反映し、ダイアログを閉じます。「キャンセル」は設定を破棄してダイアログを閉じます。

　・キー指定欄で「ウィンドウリスト」を設定している時
　　「ウィンドウサイズ」の項目
　　　ピクセル単位でのW：幅、H:高さの一覧ウィンドウの表示領域を制限できます。
　　　「0」指定は画面領域が許す限りウィンドウが広がります（マルチディスプレイの場合、またぐことはありません）。
　　　幅が表示必要量よりも小さくなったときは、ウィンドウタイトルの中間部分が「...」表示となります。
　　　高さが表示必要量よりも小さくなったときは、一覧ウィンドウがスクロール表示になります。
　　　ホイールスクロール（ミドルボタンのコロコロ）か、一覧ウィンドウ下部の矢印でスクロールできます。

　・キー指定欄で「ランチャー」を設定している時

　　ターゲット：表示したいフォルダを設定する。空白はデスクトップを意味する。
　　表示：「リスト」か「アイコン」を選ぶ。
　　アイコンサイズ：「アイコン」の大小を選ぶ。
　　ウィンドウサイズ：
　　　表示が「リスト」か「アイコン」かで意味が変わる。
　　　「リスト」→W,Hの意味は「ウィンドウリスト」の時と同じく、ピクセル単位で表示領域を制限する。
　　　「アイコン」→W,Hの意味はピクセル単位ではなく、アイコンの数を表す。
　　　　W,Hとも「0」指定→なるべく正方形(平方数)に近い形で、端数は横長になるようにアイコンをレイアウトする。
　　　　W,H片方だけ「0」指定→非ゼロ指定した幅or高さを守る形でレイアウトする。
　　　　W,H両方を非ゼロ指定→幅and高さを守る形でレイアウトする。
　　　いずれもあふれる場合はスクロール表示となる。
　　　スクロールは上下のため、高さのみ指定は端数スクロールが頻発し非推奨。幅とともに指定したほうが良い。
　　システムファイル：「表示」にチェックを入れるとdesktop.iniなどのファイルもランチャーに表示します。

## アプリランチャー：操作と設定の詳細

　アプリランチャーには、リスト表示とアイコン表示がありますが、表示の違いだけで持っている機能や操作は全く同じです。

　左クリック：アイテムの標準動作（基本は開く）／子フォルダ実体の子ウィンドウ表示
　左ダブルクリック：（子フォルダ実体のみ）アイテムの標準動作（Windows標準状態ではエクスプローラを開く）
　左ドラッグ：アイテムのドラッグ＆ドロップ
　ミドルドラッグ：アイテムのソート変更
　右クリック：アイテムのポップアップメニューを表示
　右ドラッグ：アイテムのドラッグ＆ドロップ（ドロップ時のポップアップメニュー表あり）

　ランチャー余白：ランチャー下部の余白（スクロール時は矢印の部分）や、アイコン表示の端数で生じた余白の部分
　ランチャー余白への右クリック：ランチャー用フォルダ自身のポップアップメニューを表示
　ランチャー余白へのドロップ：ランチャー用フォルダ自身へのアイテムコピー・移動・リンク操作

　これまでの説明の通り、アプリランチャーは特定のフォルダを指定して表示します。
　フォルダの中に子フォルダ(実体)が含まれる場合は、それをクリックすると階層をたどる形で小ウィンドウが表示されます。
　親のアイコン／リスト表示の如何にかかわらず、子フォルダの表示はデフォルトでリスト表示となります（後述の設定で変更可能）。
　フォルダ階層が深い場合でも、順番にクリックしていくことで目的のファイルにたどり着くことができます。
　また、子フォルダ実体はダブルクリックでエクスプローラを表示できます。

　一方でフォルダへのショートカットをクリックしても小ウィンドウは表示されません。Windows標準状態ではエクスプローラが表示されます。
　ランチャーとして使う場合、子フォルダ実体なのかショートカットなのかで挙動が大きく違うので注意してください。

　応用例：フォルダ実体のアイコン表示を変える

　　フォルダ実体のアイコンはWindowsシェルの機能で変更可能です。フォルダを右クリックして「プロパティ」を開き、「カスタマイズ」タブから
　　「アイコンの変更」ボタンを押すことで、アイコンを選択して変更することができます。

　応用例：Nethood、シンボリックリンク

　　アプリランチャーのファイル列挙にはWindowsシェル機能を使っているので、デスクトップ上のゴミ箱も見えるし、
　　Nethood機能やファイル/フォルダのシンボリックリンクも問題なく機能します(Nethoodやシンボリックリンクは各自で調べてください)。
　　ランチャー用の専用フォルダに子フォルダの実体を切っていく使い方以外にも
　　シンボリックリンクを張って子フォルダ実体のように子ウィンドウで階層をたどるような使い方も可能です。

　応用例：簡易エクスプローラ

　　ホットキー設定画面にて、アプリランチャーをターゲットを空白（デスクトップ）にして、リスト表示指定しておくと、
　　たどる階層が深くなるかもしれませんが、PC内外のどのファイルにもたどり着くことができます。
　　現在のウィンドウを最小化したりエクスプローラをわざわざ開くまでもない、ちょっとしたファイル操作をランチャー機能で対応できます。
　　Win10までタスクバーのツールバーを使っていれば、同様の利用をしていた人も多いのではないかと思います。


　ランチャー内の各アイテムは右クリックでエクスプローラ相当のポップアップメニューを表示し操作できます。
　ランチャー下部の余白もしくはスクロール矢印の部分、もしくはアイコン表示の端数で生じた余白の部分（以下「ランチャー余白」）は、
　ランチャー用に作ったフォルダ自身（ホットキー設定画面で設定したターゲットフォルダ）のポップアップメニューを表示します。
　ここでランチャー用に作ったフォルダ自身を名前変更したり削除さえできますが、当然ながらそれ以降ランチャー表示はできなくなります。

　アイテムを左クリックのドラッグすることでドラッグアンドドロップ(D&D)が可能です。ランチャーはD&Dを受けることもできます。
　アイテム上へドロップするとそのアイテムのアプリを開く操作となり、「ランチャー余白」へのドロップは、
　ランチャー用に作ったフォルダ自身（ホットキー設定画面で設定したターゲットフォルダ）へのファイルコピー・移動・リンク操作です。

　応用例：ランチャーへのアイコン追加

　　ランチャー用に作ったフォルダ自身へのD&D操作が可能であることを利用すると、
　　ランチャーへのアイコン追加のためにエクスプローラを経由する必要はありません。

　　・初回のフォルダ作成だけはエクスプローラで済ませ、ホットキー設定画面にてアプリランチャーを設定します。
　　・スタートメニューから追加したいアプリをドラッグを開始する。
　　・左ドラッグしたまま、ホットキーでアプリランチャーを表示する。
　　・アプリランチャーウィンドウの「ランチャー余白」部分へドロップ。
　　・アプリランチャーを表示しなおすと、アプリアイコンが追加されていることが確認できる。

　応用例：ウェブサイトの簡易ブックマーク共有

　　ブックマーク用フォルダを作り、ランチャー登録をしておきます。
　　edge、chrome、firefoxなどブラウザのURL欄の左側ボタンをドラックするとURLショートカットを作成できるので
　　上と同じ操作でランチャーウィンドウへD&Dして、ブックマークサイトを増やしていけます（リスト表示がいいでしょう）。
　　ブックマーク用フォルダをOneDriveやBoxDriveの上に置くと、ブラウザや端末を超えてブックマーク共有できます。

　応用例：ランチャーを使ったD&Dアプリ起動

　　あるファイルを普段はメモ帳でいいのだけど、たまにはサクラエディタで開きたいというケースへの対応事例です。
　　エクスプローラのシェル拡張で右クリックメニューにサクラエディタを登録する以外にも、以下のような応用ができます。

　　・アプリランチャーにサクラエディタを登録しておく（ランチャーはアイコン表示の方が便利でしょう）。
　　・デスクトップやエクスプローラ上で、開きたいファイルを左ドラッグ開始。
　　・左ドラッグしたまま、ホットキーでアプリランチャーを表示。
　　・アプリランチャー上のサクラエディタのアイコンへドロップ。

　ランチャーウィンドウの「ランチャー余白」部分を右クリックしたときに、ポップアップメニューの最上部に
　「子フォルダ表示プロパティ」が表示されます。これはそのフォルダに対する、ランチャー表示方法を設定することができます。
　子フォルダ実体を子ウィンドウで表示するときはデフォルトでリスト表示ですが、これを変更できます。設定項目の内容はホットキー画面と同じです。
　注意点は、ここでの表示設定はランチャーで子フォルダをたどって開く時だけに有効で、
　ホットキーで初回表示する時の表示方法はホットキー設定画面で設定する必要があります。

　例で説明します。
　デスクトップに「taskbar」フォルダを配置し、ホットキー設定画面でアイコン表示設定をしたと仮定します。
　設定どおりのホットキーで「taskbar」フォルダを表示したときはアイコン表示になります。

　別に、デスクトップをリスト表示するホットキーを設定したと仮定します。この時、デスクトップ配下にある「taskbar」を子フォルダを
　たどる形で表示することができますが、この時の「taskbar」フォルダはアイコンではなくリスト表示になります。

　このように、親フォルダからたどった時もホットキーと同じようにアイコン表示にしたいという場合に
　「taskbar」フォルダを表示しているランチャーウィンドウの「ランチャー余白」部分を右クリックし「子フォルダ表示プロパティ」で設定変更します。

　この「子フォルダ表示プロパティ」は絶対パスで保持するため、たとえばシェル最上位のデスクトップからたどったらアイコン表示だけど、
　C:\users\username\desktopからたどったらリスト表示、ということはできません。
　一方で同じランチャー用のフォルダに対してホットキー設定画面から複数のホットキーを設定することはできます。
　ある組み合わせのホットキーではアイコン表示だけど、別のホットキーではリスト表示、ということが可能です。


　最後に、ランチャーアイテムのソートについてです。
　ランチャーウィンドウでアイテムをミドルクリックでドラッグすると、ソート順を変えることができます。
　スクロールをまたがなければならないときは、ミドルドラッグしたままホイールスクロールするか（ちょっと難易度高い）、
　ミドルドラッグしたまま下部の矢印にホバー（カーソルをあててじっとしておく）するとスクロールさせることが可能です。

　ソート順は絶対パスで保持し、ホットキー／子フォルダ表示で共用です。ホットキー用の個別ソート設定はありませんので、
　ホットキーの組み合わせを変えてアイコン表示とリスト表示を併用した場合でも、ソート順を分けることはできません。
　ランチャーウィンドウの「ランチャー余白」部分を右クリックし「ソート順リセット」を選ぶと、Windowsシェルの名前順に戻ります。

## ウィンドウ切替：操作と設定の詳細

　ウィンドウ切替で各アイテムに対し可能な操作は左クリック：ウィンドウ切替、右クリック：システムメニューを開く、の2点だけです。
　この項での説明事項は、すべてアイテムのグルーピングやソート順に関する仕様や操作に関する説明のみです。

　左クリック：ウィンドウを切り替える
　右クリック：ウィンドウのシステムメニューを表示する(閉じる、最大化、最小化など)

　左ドラッグ：グループのソート順変更
　ミドルドラッグ：１つのウィンドウのソート変更
　ミドルクリック：１つのウィンドウのグループ変更

　・アイテムのグルーピング

　　ウィンドウ切替一覧上で、左側にグループを見分けるバー表示があります。

　　　　自動グループ：単一メンバでバー表示なし／複数メンバで黒いバー表示
　　　　任意グループ：単一・複数メンバとも薄緑バー表示

　　ウィンドウ切替一覧における各アイテムは、プロセスイメージ名※が同一の時に自動でグルーピングします。
　　自動グループには、プロセスイメージ名が異なるアイテムが所属することはできません。
　　　※プロセスイメージ名：ウィンドウを表示しているプロセスのexeファイルの絶対パス

　　その他に、利用者が任意にグループを指定できる任意グループがあります。
　　任意グループには、プロセスイメージ名が異なるアイテムも含め、利用者が所属アイテムを自由に設定できます。
　　（目的が同一のexcelとwordのウィンドウを同一グループにするなど）

　　新しいウィンドウができると、新しい自動グループができるか既存の自動グループのメンバが増えます。
　　一方で任意グループのメンバが自動で増えることはありません。

　・アイテムのソート
　　ウィンドウ切替一覧におけるソートはグループ単位で行います。（グループ化されていないアイテムも、メンバが一つのグループとみなす）。
　　このグループ単位のソートは左ドラッグで行います。

　　複数のメンバが存在するグループの場合、グループ内でのメンバのソートも変えることができます。
　　グループ内のメンバのソートはミドルクリックで行います。
　　アイテムのミドルドラッグでは、対象アイテムをグループまたぎで移動することもできます（後述の制約があります）。

　　ソートがスクロールをまたぐ場合は、ドラッグしたままホイールスクロールするか（ミドルボタンの時はちょっと難易度高い）、
　　ドラッグしたまま下部の矢印にホバー（カーソルをあててじっとしておく）するとスクロールさせることが可能です。

　・グルーピングの変更
　　自動グループにはプロセスイメージ名が異なるアイテムが所属できないので、自動グループしか無い初期状態ではグループ間の移動は全くできません。
　　グループに関するルールを書きますがちょっと複雑です。実際にミドルクリックとミドルドラッグをいろいろやってみてください。

　　ウィンドウ切替一覧における各アイテムに対して、ミドルクリックするとアイテムのグループの種類を変更することができます。

　　自動グループに属しているアイテムはグループから外れ、単一の任意グループのアイテムになります。
　　複数メンバの任意グループに属しているアイテムはグループを外れて、単一の任意グループのアイテムになります。
　　任意グループに対しては、任意のアイテムをミドルドラッグの操作にて所属させることができます。

　　単一の任意グループのアイテムに対して、ミドルクリックすると自動グループに戻すことができます。
　　ただし、同じプロセスイメージ名を持つ自動グループがないことが条件になります。
　　ほかに同じプロセスイメージ名を持つ自動グループがあるときは、任意グループのアイテムを自動グループに所属させることができます。

　・ソート順の事前設定

　　◎ウィンドウのソート順は揮発性です。プログラムが終了すると残りません。タスクバー上の並び順とも連動しません。
　　ただし、自動グループの並び順については、あらかじめ指定しておくことができます。

　　・並び順を設定したいウィンドウを一つ以上起動しておきます。
　　　起動していないウィンドウはソート設定画面に候補表示されないので、ソート設定できません。
　　・タスクバー通知アイコン「mytaskbar」を右クリックし「ウィンドウリスト:ソート設定」を選びます。
　　・起動しているプロセスイメージ名(exeファイル)の一覧が表示されます。
　　　アイテムをミドルクリックすると、アイコン左側に黒い四角が表示されます。
　　　黒いバーがついているアイテムはソート順の指定対象となります。
　　　ソート指定対象のアイテムは左ドラッグで順序を入れ替えることができます。
　　・「ＯＫ」ボタンで設定が反映されます。

　　◎プログラムを起動してから一度でもウィンドウ切替を表示していると、その時に表示されたソート順が保持されるので、
　　上記の設定画面で設定したソート順が反映されるわけではありません。
　　設定の効果を確認したい場合は、本プログラムを一度終了させて再起動し、ウィンドウ切替を表示してみてください。

　　設定画面で設定したアイテムは一覧の下の方に指定した順で並び、ソート対象指定しないプロセスは、一覧の上の方に
　　ランダムに並ぶことが確認できると思います。ソート指定されていない新しいウィンドウは上の方に並ぶ仕組みです。
　　（新ウィンドウを生成し、ホットキーでウィンドウ切替を表示し選ぶときに、新しいものが上にあってほしいという考え方）
　　自分が起動する可能性のあるプロセスをしらみつぶしにソート順設定をしておくと並びを固定化できます。

　　◎対象のプロセスイメージ(exeファイルのフルパス)がバージョンアップでどんどん名前が変わってしまうケースがあります。
　　パスが変わる都度、ソート設定を変える煩雑さの回避のため、ワイルドカードを指定することができます。
　　画面で一旦ソート設定したうえでレジストリ値を修正します。意味が分からない人は危険のため、操作しないでください。

　　・レジストリエディタを起動します。
　　・「HKEY_CURRENT_USER\SOFTWARE\myprogram\mytaskbar」キーを開きます。
　　・「win_sort」値を開きます。
　　・該当のフルパスのうち、一部をアスタリスクに置き換えます。
　　　C:\Program Files\WindowsApps\MSTeams_nnnnn.nnn.nnnn.nnn_x64__8wekyb3d8bbwe\ms-teams.exe
　　　　↓
　　　C:\Program Files\WindowsApps\MSTeams_*_x64__8wekyb3d8bbwe\ms-teams.exe
　　・アスタリスクは複数設定可能で、case sensitiveの単純な貪欲検索です。プロセスイメージが複数ヒットしてしまうような
　　　緩いワイルドカードでは動作がおかしくなるので注意してください。

## 既知の事象
　◎ウィンドウ切替のソート順はタスクバーと連動しません。
　◎アプリランチャーでzipをフォルダ扱いでファイル一覧表示が可能ですが、クリックでの操作はできません。

## トラブルシューティング

　アプリランチャー／ウィンドウ切替共通
　　ホットキーを押しても表示されない
　　　◎別アプリとホットキーが衝突していないか：
　　　　別アプリをすべて停止させてみる、ホットキーの指定を変えてみる
　　　◎ホットキー設定画面のウィンドウサイズ指定が小さすぎる：
　　　　W、Hともにゼロを指定してみる

　　二重起動でランチャーが表示できない
　　　◎引数が間違っていないか：
　　　　引数は半角大文字で2文字。受け付けるのはS?、A?、N?のみ。?の部分は1-0、A-Z、-^|@[;:],./_、のいずれか

　アプリランチャー
　　ホットキーを押しても表示されない
　　　◎ターゲットの指定が間違っていないか：
　　　　　ターゲットの指定を空白にして、デスクトップが表示されるか確かめる
　　　　　→表示される場合は、ターゲット指定が間違っている可能性が高い。
　　　　　対象のフォルダをエクスプローラ等でSHIFT+右クリックし、「パスのコピー」を選んで、ターゲット指定に張り付けてみる

　・ウィンドウ切替
　　ホットキーを押しても表示されない
　　　◎表示に気づきにくい：
　　　　　別のアプリが一つも起動していないと、一覧ウィンドウがとても小さくなる。別アプリを起動してみる。

～～～～～

Rust
・所有権、借用の考え方
　コーディングしていく場面では、変数がどこで消費されてしまうか、を考えながら作業するという意識が必要。
　グローバル変数がない（厳密には無いわけでは無いのですが、Rustは基本的に許さないスタンス）というのも
　軽いプログラムを組むうえでは特に結構コーディング作業に影響する。
　
　（Webアプリプログラムなど、多重処理前提で、フレームワークに乗っかって書く場合は、グローバル変数なんて無いのが基本前提になるので、
　　そのような文脈で仕事している人には、制約とは映らないと思う。）

　プログラムの処理というのは、一つのプログラムは関数をまたいだり、多くのソースファイルをまたいだり、
　よそから引っ張ってきたライブラリを使ったりと、複雑な構造を持ちますが、どんなに複雑でもエントリポイント(Main関数)から
　一筆書きでプログラムは進行するわけです（スレッドまたがるともちろん一本ではないですが、それでもそのスレッドの生成をたどれば元はひとつ）。
　業務アプリでは、フレームワークに乗ってMain関数を目にしないプログラミングスタイルがほとんどだと思う。

　グローバル変数を許さないRustの所有権は、そんなことも改めて意識させられる。
　どういうことかというと

　・プログラムの起動から終了までのライフサイクルにおいて、生き続けなければいけないメモリ(変数)は、Mainの最初で生成されて、
　　それがMainを抜けるとき(プログラムが終了)する時に解放される(Drop)される必要がある。
　・同じように、あるメモリ(変数)が生きていなければいけない区間内(ブロック)で生成されて、最後でDropされる必要がある。

というわけで、基本的にRustのプログラミングでは、変数は生成した直後から消費される運命にあるという意識で書く。

＝＝＝＝＝

fn main() {
    let x = String::from("abc");
    let y = x;
    println!("{x:}"); // エラー(xはムーブ済)
}


これがコンパイルエラーになるのがRustの真骨頂でしょう。println文におけるxが参照エラーになります。
エラーになるのが自然と思えればRustに慣れてきたと言えるでしょう（？？）。他言語からRustに入ってきた人は違和感しかないと思います。

Rustではlet y = x;の代入がコピーではなくムーブを意味します。これがコーディングの上で多言語との違いになる「根本」です。
（ムーブがRustで唯一というわけでもなくC++でも挙動が追加されています。対比によるRust理解が目的ですので、ここでは除外します。）

なお、Rustでもコピーはあります。プリミティブな型などCopyトレイトを実装している型ではコピーになります（その型ではムーブは起こしたくても起こせません）。
以下では、Copyトレイト実装のない型の変数を念頭に、メモリ管理を説明します。


Ａ）他言語では、あるブロック内で生成した変数は、代入や関数への引き渡しにてコピーが作られます。しかし、元の変数はブロック外へ出ること無くブロックの終了で消滅します。
　　変数のコピーがブロックを超えて発生することはあっても、それらも必ずそのコピー先のブロック終了で消滅します。

Ｂ）Rustでは、あるブロック内で生成した変数には、以下の３つのルートがあります。
　　①や②のムーブ（所有権のバトン渡し）を経たのちに、最終的に全て必ず③に到達して変数が消滅します。

　①別のブロックへ変数を引き渡すことでムーブし、元のブロック内から消える（引き渡した変数は、引き渡し先のブロックが管理する）。
　②そのブロックからリターン値として返却することでムーブし、元のブロック内から消える（返却された変数は、返却先のブロックが管理する）。
　③ブロック外へムーブしないままブロック終了を迎えると、消滅する。


ここまでの説明だけだとＡ）、Ｂ）のどちらにもメモリの解放漏れのリスクはないように思えます。
実際に、GCのないC言語やC++であってもmallocやnewの発生しないコーディングをする限りは、ブロック終了による変数消滅の仕組みだけでメモリリークのリスクは生じません。

＝＝＝＝＝＝

メモリリークのリスクについて、他言語とRustでインスタンスの生成例を使って説明したいと思います。

【C ++】
String *x = new String("abc");
String *y = x;

【Java】
String x = new String("abc"); 
y = x;

	（あ）他言語における参照と、代入構文/関数引数で生じるコピー
	x --> <heap>
	y --> 

【Rust】
let x = String::from("abc");
let y = x;

	（い）Rustにおける参照と、代入構文/関数引数でのムーブ
	x --> <heap>
	　↓
	x 消滅
	y --> <heap>


他言語とRustのヒープを指す参照の状態を見比べてもらうと分かると思いますが、
他言語ではヒープを指すアドレスが複数ある状態となり、Rustではそうなりません。
Rustではヒープを管理する変数が常に一つ（所有権）になるように、コンパイルルールでコーディングを制限します。
だから、その変数がブロックの終了にて消滅するときに、必ず一緒にヒープも解放することでメモリリークが回避できます。
これがGC無しにメモリリークを回避するRustの方法論であり、実行時ではなくコンパイル時に担保できるところが素晴らしいところです。

他言語では、ヒープ解放の責任の所在は変数にありません。参照の複製がコード内の複数個所に現れうるので
いつヒープが不要になって解放できるかということと、特定の変数の消滅とは１対１に結びつきません。
C言語やC++ではヒープの解放はプログラマ任せであり、参照（ポインタ）を持った変数を消失させてしまうとメモリリークします。
GCのある言語はGCがヒープを参照する変数（図あのxやy）の消滅を監視して、実行中にそれらが全て無くなったと判断したらヒープを解放します。

＝＝＝＝＝

ここまでで、RustがどうやってGC無しにメモリリークのリスクを回避しているかを見てきました。
所有権のコーディングルールは単純かつ、かなり不便な制約です。なので所有権と借用をセットでRustが語られます。
借用を説明していきますが、はっきり言って借用があっても不便です。
というか、借用を使っても不便さの本質は何も変わりません。そのあたりを説明していきます。

が、その前にまず、本題の前にRustにおけるCloneとCopyを説明します。
図いのように所有権の仕組みに沿って変数をムーブさせていくだけではプログラム処理が成立しません。
Rustでデータのコピーを作る仕組みがCloneトレイトです。Cloneトレイトを実装している型のインスタンスのcloneメソッドを
呼ぶと、参照の複製ではなくデータをコピーが返却されます。図うの状態の状態となります。
図あの状態と比較してください、図うであれば抵触していないことが分かると思います。
（この操作をディープコピーと呼びます。C++ではコピーコンストラクタ、Javaでは標準クラスのCloneableで実装します。）

	（う）Rustにおけるコピー（＝クローンを暗黙で実施する）
	x --> <heap>
	y --> <heap>

Rsutにおける借用というのは、参照への参照です。変更不可能（immutable）と変更可能（mutable）の借用があります。

fn main() {
    let mut x = String::from("abc");
    let y = &x;
    println!("{x:}, {y:}"); // 両方の変数から読み取り可能
}

fn main() {
    let mut x = String::from("abc");
    let y = &mut x;
    y.push_str("def");
    println!("{x:}"); // 借用を通じて借用元の状態を変更可能
}

なるほど。借用があれば便利そうです。が、①immut借用とmut借用は併用不可、②mut借用は同時に1つまでというルールがあります。
よって以下のコードはコンパイルエラーとなります。let y = &x; をlet y = &mut x;に変えても②のルールに抵触しエラーになります。

fn main() {
    let mut x = String::from("abc");
    let y = &x;
    x.push_str("def"); // エラー(①immutとmut借用の併用や、②二重のmut借用は不可)
    println!("{y:}");
}

	（え）Rustにおけるimmut借用
	y --immut--> x --> <heap>
	z --immut--> 
	w --mut-->   存在を許さない

	（お）Rustにおけるmut借用
	y --mut-->  x --> <heap>
	z --immut-> 存在を許さない
	w --mut-->  存在を許さない

要するに、借用に関する①・②のルールは以下のように書き換えられます。
　①immut借用を取っている間は借用元のデータに変更は加えられない。
　②データを変更する変数の使用は、同時に一か所だけ。
この厳しい借用ルールがRustのデータ安全性の根幹です。そりゃ安全になるよねという単純かつ完璧なルールです。

データベースにおける排他制御と比較してみてください。Rustの借用は参照ではありません。ロック獲得なのです。
ロックというと多重処理・スレッド間を連想されるかもしれませんが、そうではなくRustのこのルールは単一スレッドで効くのです。
単一スレッドでこんな制約を課す意味はあるのか、過剰じゃないのかと思うかもしれません。
実際に、人間にはそれが問題ないとわかっても、借用ルールに引っかかって歯がゆい思いをする場面があるのは事実です。
ですが単一スレッドのプログラムであっても、例えば、変更されないことを前提にしたコレクションのイテレーションをループする中で
そのイテレーションに影響する変更操作をしてしまうなど、そういったプログラムミスは起き得ます。そういう操作を未然に防げるのです。


さて、冒頭に「借用を使っても不便さの本質は何も変わらない」と書きましたが、これだけ厳しいルールがあるので、
他言語において参照(ポインタ)をいろんなところで複製したり保持したり、というような利便性は得られません。
性能面を度外視すれば、immut借用は元変数のクローン生成を取ることで代替可能です。
借用ルールを回避できるのでコンパイルエラーを回避するのにクローンが必須の場合もあります。
また、コーディングの煩雑さを度外視すれば、mut借用を関数へ渡しブロック外へ持ち出すことは、元変数のムーブ＆返却と同義です。

ま、実際にはそんなことはせず借用を使ってください。ですが、なぜこんな事を書いたかというと、
借用で出来ることがこの程度だということを認識しておくことはRustコーディングの上で有用です。
Rustの原則（所有権と借用）から生じる不便さを軽減する型がいくつかありますが、それを使うべき時が理解しやすくなります。

コンパイルで借用エラーが出た場合、性能的に許容できるなら、借用回避のためだけにコードが汚れるよりは
クローンの方が良いことが多いと思います。頻繁なクローンには抵抗あるかもしれませんが気持ちの問題であれば、
GC不要／安全性のための代償と思えば安いオーバーヘッドと思えるケースが多いのではないかと思います。

性能面でＮＧの場合は、取れる対策は以下のようなものがあります。

１）コードが長くなって見づらい等の理由で借用を変数にバインドしているのなら、利用個所に借用を直接記述する。

	let item = &self.member_vec[&self.now_index];
	let ret = hogefuga(item.member1);
	self.another_member = ret; // 借用エラー
	foobar(item.member2);
	　↓
	let ret = hogefuga(self.member_vec[&self.now_index].member1);
	self.another_member = ret; // コンパイルＯＫ
	foobar(self.member_vec[&self.now_index].member2);

２）処理順を変えて、借用ルール制約を回避できないか。
３）VecやHashMapなど借用する場合、利用データが範囲が限定的ならコレクションのデータの一部をコピー退避して回避できないか。
４）VecやHashMapなどを借用するのではなく、インデックスやキー（先にkeysで取り出しクローン退避）でアクセスできないか。
５）構造体のメンバ変数に対する借用が構造体全体の借用に波及することが原因で借用エラーとなる場合は、
　そのメンバ変数をOptionでくるみ、一時的にswapやtakeやで構造体から外に出し、使い終わったら元に戻す。

他言語の経験を持ってRustに入ってきて、とりあえずコーディングを始めると借用エラーで訳がわからず辛いところです。
Rustを始めた最初の頃、特に１番目の例は私にはいったい何が違うのか訳分かりませんでした。一応解説しておくと、
修正後は、最初のhogefuga呼び出し終了後にselfのimmut借用が終わるので、another_memberを修正できるようになるということです。
また修正前でもitemを後続で利用しなければ（foobar呼び出しをやめると）、コンパイラが借用を終えたと判断しエラーになりません。

こういうことは他言語ではまずまず起きませんから、本当にRust独特だと思いますが、慣れるしかありません。

＝＝＝＝＝

Rustでは図いや図うの状態を強制され、不便なプログラミングを強いられると書きましたが、
それだけでは実現不可能なデータ構造があります。Rust Bookにも例がある通り、複数の親を持つ連結リストなどが該当します。
その場合は、スマートポインタのRust実装であるRcを使います。これは、図あとの対比で図あ’のように表現できます。

	（あ’）RustのRc構造
	x --> リファレンスカウント＋<heap>
	y --> 

図あではひとつのヒープに複数の参照が存在し、他言語ではメモリ解放の責任所在が変数に紐づかないと説明しました。
Rustにおける図あ’はまさに変数とメモリ解放の責任所在が紐づかない形となります。

その代わり、リファレンスカウンタを保持することでメモリ解放を担保します。リファレンスカウンタはその名の通り
参照している変数の数を保持しており、参照する変数の増減でカウンタも増減し、カウンタがゼロになったとき（最後の変数が消滅したとき）に
ヒープも一緒に解放されます。この仕組みでメモリリークのリスクを回避します
（参照の構造がループするとき解放漏れが生じます。DBのデッドロックを避けるのと同類の問題として、このようなコーディングの回避はプログラマ責任になります。
多くのGCではこのようなケースでも解放してくれるので、Rustの方式ではGC不要による性能メリットとこの問題がトレードオフの関係にあります。）

厳しい借用ルール（参照と変更の共存不可、変更は１か所）はこの方式だとコンパイル時にチェックできなくなり、実行時にチェックされるようになります。
このスマートポインタによって他言語でのコーディング制約はかなり縮まりますが、借用ルールが他言語との一番の違いとして残ります。
借用ルールが残るため、他言語のプログラムをそのままの構造でRustへ移植すると、うまく動かないことが出てきます。

スマートポインタを使うことで参照をいろいろなところ保持できるようになりますが、実際のコーディングでは普通の変数と比べて記述量が増え面倒になっています。
言語設計としてあえて面倒にしているという事さえ感じます。
スマートポインタにかかわらずRustコーディングする際にデータ構造の設計で気を付けるべき方針を書きます。

・オブジェクト指向的な考え方はRustでは限定的に適用可能であり、注意するべき点が多い。
　・構造体のメンバを借用すると、借用ルールは部分適用ではなく構造体全体に及ぶため、コーディング上の制約となるケースがある。
　　→単にカプセル化が目的であれば、モジュール単位やファイル単位のスコープで達成できる。

　・クラス継承はRustにはありません。構造体と構造体には直接の関係構造は持てないので、同じ振る舞い（トレイト）でまとめ上げていく考え方で設計する。
　　オブジェクト指向経験者＆Rust初心者は、ひとまずトレイトはオブジェクト指向のインタフェースと同じと思ってよいです。
　　ただし、インタフェースはクラスの宣言者が宣言するものですが、トレイトは既存の型の利用者が「生やす」ことができるのが大きな違いです。
　　（既存の型に生やせるといっても、それを利用できるのはその利用者が実装する範囲に限定され、外には持ち出せないので、既存コードへは影響せず安全が担保される）

・構造体間の借用保持は極力避ける。

　親が子を所有するというツリーがネストしていくという構造は、他言語でも基本的に違和感なくそうなると思いますし、Rustでも自然です。
　しかし、子から親をたどるために、親の参照を保持するということはRustでは単純ではありません。

　まず、参照のために親の借用を保持する場合、実体である親が子よりも長く生きることをコンパイラに伝えるため、ライフタイムの記述が必要となりコーディングが非常に煩雑になります。
　また、子から親の状態を変更しなければならずmut借用を保持する場合、そのような子が複数存在すると破綻します（mut借用は同時にひとつというルールに抵触）。
　Rustの借用はロック獲得と同義と書きました。そもそも借用を構造体に保持するということは言わばロックしっぱなしです。
　これらのことを分かってなお、借用を使うケースもあるかもしれません。ですが、基本的には借用を参照代わりには使ってはいけません。

　Rustでは参照保持の目的にはスマートポインタ(Rc)を使う必要があります。これを使うと借用ルールの制約はコンパイルチェックから実行時チェックに送ることができ、
　実行時の借用ルール違反がなければ、正しく動作します。もう一つ気を付けなければいけないことがあり、強参照と弱参照の違いです。
　強参照を保持することはその参照先の保有を意味します。保有を意味しない参照は弱参照を使う必要があります。
　親子の例でいえば、親は子を強参照で保有し、子も親を強参照で保有したら保有関係のループが生じRustでもメモリリークします。
　子は親を所有しているわけではないので、子には親の弱参照を保有するのが基本です。

＝＝＝＝＝

苦労したところや実装ポイント
・AppとMainWindowの参照関係
・メッセージプロシジャのコールバック：リエントラント





Javaとは異なり、CやC++ではスタックにもヒープにも構造体やクラスインスタンスの生成ができます。構造体やクラスの中にポインタを含まなければ、
スタック生成のデータは、変数のブロック終了での消滅の原則が守られるためメモリリークのリスクは起きません。
ヒープにデータを作ると、必ずポインタが必要となります。そのポインタの取り扱いがメモリリークのリスク要因となります。
また、C++では演算子のオーバーロードが存在し、これによって起きていることが非常に分かりづらくなるのですが、代入構文がディープコピーになるときもあります。
理解をして正確に使っている分には便利な時もあるのですが、要するにとても複雑でミスを誘うのです。）


他言語とRustの大きな違いに「ムーブ」があり、Rustのコーディング上ではこのムーブの性質が結構やっかいなのですが、
実はムーブは性能のための仕組みであって、メモリ解放漏れを達成するうえで必須の仕組みではありません。コピーで全て代用可能です。

では、Rustはメモリ解放漏れのリスクをどうやって防いでいるのか。

上で触れたようにそのリスクは、C言語やC++ではmallocやnewで生じ、freeやdeleteの呼び出し責任をプログラマが負っていることがリスクの本質です。
GCは、そのfreeやdeleteに相当する呼び出しをプログラマから隠蔽しリスクを回避しています（その分、性能上のオーバーヘッドを負う）。
流れからも分かると思いますが、答えから言うとRustはfreeやdelete呼び出しを上記の③ブロック終了による変数消滅と紐づけています。
字面だけだと、いたって単純ですよね。ですが、CやC++で問題になったことに対して、他言語ではGCを使って回避しています。
この部分がGC無しでメモリ解放リスク無しを実現するRustを使った時に、プログラマがコーディング上で支払う代償と直結するということになります。

C/C++でもJavaでも動的なメモリ確保（ヒープアロケーション）をした時、その変数は実体ではなく、変数は参照となっています。
メモリ管理上、実体はヒープ領域に格納されます。参照はヒープ領域のどこに実体が格納されているかのメモリアドレス＝ポインタです。
そして、上述のＡ）他言語では、変数がブロック外へ出ることなくブロック終了で消滅すると書きましたが、動的メモリ確保で得た変数が
消滅しても、それは参照が消滅しただけなのです。他言語では、変数は自由にコピーできて、ブロックを超えて参照がちらばることができますが
実体はヒープ上でひとつであり、それは変数（参照）がいくつあろうがなかろうが関係ないのです。





リスクの本質＝「freeやdeleteの呼び出しがプログラマ責任」をもう少し掘り下げます。






    let mut x = 1;
    let y = &x;
    let z = y; // コピー
    println!("{y:}"); // ＯＫ

    let mut x = 1;
    let y = &mut x;
    let z = y; // ムーブ
    println!("{y:}"); // エラー



GC無しに解放漏れのないメモリ管理を達成しているのは、最終的に全て必ず③に到達することを担保するからです。
このように他言語と




（後で触れますが、mallocやnewを書いた瞬間から解放漏れのリスクが生じます）。
GCのないC言語やC++であっても、ブロック内で生成した変数にアロケーションを伴わないなら(mallocやnewしなければ)、




C言語ではアロケーションとその解放のすべてがプログラマの責任になる（ただし、C言語でもスマートポインタを徹底すればRustに近い安全なコーディングができる。
あとは言語がそれをどれだけ強制してくるかの違いだけ。Rustだって、いつでもunsafeを書くことができ、文字通りそのコードはunsafeである可能性をはらむ。）


RustはGCのないメモリ安全を実現しているために所有権と借用を導入しているとよく語られますが、
コーディングの場面では、どこで「消費」するかに気を付けるということが実際かと思います。

・C言語ではあるブロック内でアロケーションしたポインタを、ブロック外に持ち出して保持・複製でき、任意に解放操作もできる（解放し忘れても気づかない）。
　だから、解放漏れのためポインタを見失わないようには気を使っても、変数の消費にいちいち気は使わない。
　結果的にプログラムが複雑になってくると、実体のない参照、誤った参照や破壊、解放漏れが生じてくる。

・JavaやC#等のGCのある言語でも、あるブロック内で生成した変数の参照やその複製を、ブロック外でも自由に保持できる。
　メモリの解放は参照が残っているかどうかでGCがタイミングを決めるので、変数の消費についてプログラマはほとんど意識しない。
　メモリ解放をプログラマに管理させないので、実体のない参照、誤った参照や破壊、メモリの解放漏れは置き得ない
　（安全だが性能面の問題と、メモリ解放にリソースのクローズが紐づくケースでリークが起きたりする。また、参照のNULLを許容しているのでヌルポ問題は残っている）。

・Rustでは上記の問題に対処するために所有権と借用を導入している。
　これを変数の消費(メモリ解放)という観点で見ると、

　・ブロックの中で生成した変数は、そのブロックを抜けるときに消費される（そのブロックに消費権がある）。
　・別の変数へ実体を代入したり、別の関数に変数の実体を渡すと、その時点で変数は消費し相手に消費する権利が移る（ムーブ）。

　・呼び出した関数から実体が返ってきたとき、その変数の消費権を呼び出し元が得るということ。

　・関数にimmut参照を渡すと、相手に中身を変える権利も消費する権利も与えない。
　・関数にmut参照を渡すと、相手に中身を変える権利を与えるが、消費する権利は与えない
　・呼び出した関数から参照が返ってきたとき、その参照が指し示す実体を呼び出し元自身が所有しているか、上位から実体への参照を呼び出し元が受け取っているということ。

　・mut参照は同時に１つでしか存在できない。複数のimmut参照は許容されるが、mut参照とは同居できない。

　・変数が宣言されているのに中身がないとか、不定な状態を許さない（後からすぐに値を入れるとわかっていても、配列などは全要素を必ず初期値セットする必要がある）。
　・構造体の消費はそれ全体で行われるので、一部の変数だけ持ち出すことはできない（再代入や、Optionでくるんだ変数のtakeやreplaceは可能)

　・Clone, Copyを実装した変数の場合、関数に実体を渡すとその複製が渡され、呼び出し元でその変数を消費する権利をそのまま持つ。
　・プリミティブな変数はClone, Copy実装を持っており、複製の実体渡し(C言語でいう値渡し)になる。
　　（Rustでは訳も分からずCopyは実装しないのが鉄則。Copyを実装するとムーブは全く起きなくなり、思わぬところで複製渡しが発生する。
　　　参照を渡すべき所に気づきにくくなり、渡し先で複製をいくら変更しても複製元には反映されないというミスが起きやすくなる。）

このような消費の仕組みによって、CやJavaにあった参照の自由な複製や任意のコード場所でのデータ変更が制限される代わりに、GC不要で安全なメモリ管理が達成される。

Rustでコーディングをしていると、まずまずこの所有権で悩まされる。

　処理の順序など



他の言語では特段に意識せずにかけることが、Rustでは所有権に引っかかることがある。
性能面を意識すれば、構造体やStringやVecなどに対して極力クローンはしたくないが、どうしようもない、
もしくはクローンを回避するにはプログラム構造を大きく変える必要に迫られるという場面も起きる。
そんな時は無理せずクローンすることを選んでよいと思う。それはGCなしに安全なメモリ管理をやるための代償と思えば安い。

話が逸れるが、Rustでは変数ひとつアクセスするにもいちいちunwrap等しなければならないケースが非常に多く、
それにかかるオーバーヘッドはどうなんだろうともやもやするかもしれないが、実際にはそれほどのオーバーヘッドにはならず
ループ箇所でよほど性能を極限に切り詰める必要がある場合でもない限り、全く気にしなくてよい。
むしろ、制御しづらい例外処理をなくし、かつ、手抜かりなく安全にエラーハンドリングをするためのコストだと思えば安い。


＝＝＝＝＝

Vecと配列とスライスがわかりづらさ満点。この違いを理解するとStringがわかりやすくなる。
他言語の配列は伸び縮みできることが多いので混乱要素になるし、
カギかっこ[]で配列を表すだけでなく、スライスもあらわすのでその違いが非常にわかりにくい。

・Vecはコンパイル時に要素数が決まっている必要はなく、伸び縮みができる。
・配列はコンパイル時に要素数が決まっている必要があり、伸び縮みもできない。実体やmut参照から要素の値を書き換えることはできる。
・スライスは、Vecや配列の全部または一部に対する参照(単独では存在せず、実体はVecか配列)。
　要素数はコンパイル時に決まっている必要はないが、一度生成したら伸び縮みはできない。
　mut参照から要素の値をひとつひとつ書き換えることはできる。

要素数が固定という特性から、配列はあまり使う機会は多くない（配列はvecの要素数固定版と思えば後は同じ）。
Rustコード上に出てくるカギかっこ[]はVecに対するスライスを表している。
let v = vec!(0, 1, 2);
v[1] = 5; //2番目の要素を5に変更する（スライスを通した要素値の変更）
println!("{:?"}, v[1..=2]); //2～3番目のスライスを表す（左辺値にして代入することはできない）

String = UTF-8が格納されたVec<u8>。
&strはStringの一部または全部のバイト列への参照＝スライス。
let s = String::from("abcdefg");
let p = &s[1..=3]; "bcd"が取り出せる

ただし、UTF-8は1～4バイトで１文字を構成されるため、
たとえば全角文字の中途半端なところでスライスを切り出そうとするとpanic。これがやっかい。
findで文字位置を得て、スライスで切り出す分には問題ないが、全角が混じってくるかもしれない状況で
何文字目という切り出し方はStringのままでは出来ないと思ったほうが良い。chars()を使う（参照．．．）

&Stringと&strは、Stringへの参照かスライスかで別物だけど、できることも同じなので同じと思ってよく、
引数に&strが要求されていて&Stringしてもコンパイラが自動に変換して扱ってくれる。
一方で&mut Stringは&mut strと全く異なる。前者は文字の追加や削除など編集ができるが、後者はmutで得る意味はほぼがない。
（&mut strは理屈上はUTF-8バイト配列の値を書き得られてもよさそうだが、そのような関数や演算子は用意されていない）

・文字列の結合→String + &str
・特定文字を探して切り出し→String::split()や、find()で得た位置を使ってスライス&String[i..] &str[i..]
・？文字目から？文字目の切り出し→String::chars_indices()で位置を得てスライス
    
    let s = "abあdeいfgう".to_string();

    let mut i = s.char_indices();
    let st = i.nth(2).unwrap().0;
    let ed = i.nth(3).unwrap().0; // iterを1週に
    let p = &s[st..ed]; // 得られるのは&str

    let st = s.char_indices().nth(2).unwrap().0;
    let ed = s.char_indices().nth(6).unwrap().0; // iterが2週走る
    let p = &s[st..ed]; // 得られるのは&str

    let ci = s.char_indices().collect::<Vec<_>>(); // iter1週させ、Vecアロケーション発生
    let p = &s[ci[2].0..ci[6].0]; // 得られるのは&str

    let c = s.chars().collect::<Vec<_>>(); // どうせアロケーションするなら元のString切り出しでなくcharをcollectする手もあり
    let p = c[2..6].iter().collect::<String>(); // Stringのアロケーションも発生

    let p = s.chars().collect::<Vec<_>>().iter().skip(2).take(4).collect::<String>(); // 1回だけならこれでもいい
    println!("{p:}");

並びは性能の良い順。最適化コンパイルで1000万回繰り返すと、1～2は100ms台で3～5は1.5～2.5秒程度の結果だった。
文字数が長くなると、4と5は逆転すると思うが、短いとskip,takeの方がオーバーヘッドがあるみたい。
ま、繰り返しが多くなければ、見た目の好きなのを選んでよいと思う。
後続で文字列結合などまだ編集が続くならどうせStringが必要なわけだからString化も悪くないか。

